package org.bodtx.telebluetooth;

import java.io.IOException;
import java.util.UUID;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.util.Log;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends Activity {

	private static final String TAG = "MyActivity";


	private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(Context context, Intent intent) {
			final String action = intent.getAction();

			if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
				final int state = intent.getIntExtra(
						BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
				switch (state) {
				case BluetoothAdapter.STATE_ON:
					textView.append("Bluetooth on\n");
					startConnection();
					break;
				case BluetoothAdapter.STATE_TURNING_ON:
					textView.append("Turning Bluetooth on...\n");
					break;
				}
			}
		}
	};

	TextView textView;
	private BluetoothAdapter mBluetoothAdapter;
	private ConnectThread connectThread;
	Button buttonOn;
	Button buttonOff;


	private Listener listener;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		buttonOn = (Button) findViewById(R.id.onCommand);
		buttonOff = (Button) findViewById(R.id.offCommand);
		textView = (TextView) findViewById(R.id.edit_message);
		mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

		// Register for broadcasts on BluetoothAdapter state change
		IntentFilter filter = new IntentFilter(
				BluetoothAdapter.ACTION_STATE_CHANGED);
		this.registerReceiver(mReceiver, filter);

		if (mBluetoothAdapter == null) {
			textView.setText("bluetooth non supporté");
		} else {
			if (!mBluetoothAdapter.isEnabled()) {
				mBluetoothAdapter.enable();
			} else {
				startConnection();
			}
		}
	}

	private void startConnection() {
		BluetoothSocket socket = null;
		BluetoothDevice device = mBluetoothAdapter
				.getRemoteDevice("20:13:10:15:38:91");
		mBluetoothAdapter.cancelDiscovery();
		try {
			socket = device.createRfcommSocketToServiceRecord(UUID
					.fromString("00001101-0000-1000-8000-00805F9B34FB"));
			socket.connect();
		} catch (IOException e) {
			Log.e(TAG, e.getMessage());
		}
		listener = new Listener(socket);
		listener.start();
		connectThread = new ConnectThread(socket);
		connectThread.start();
		
	}

	@Override
	protected void onDestroy() {
		mBluetoothAdapter.disable();
		this.unregisterReceiver(mReceiver);
		connectThread.cancel();
		listener.cancel();
		super.onDestroy();
	}
	
	private class Listener extends Thread {

		private final BluetoothSocket mmSocket;
		
		public Listener(BluetoothSocket socket){
			this.mmSocket = socket;
			
		}
		@Override
		public void run() {
			try {
				int state;
				while((state = mmSocket.getInputStream().read()) > 0){
					if(0 == state){
						mmSocket.getOutputStream().write("on".getBytes());
					} else{
						mmSocket.getOutputStream().write("off".getBytes());
					}
					
				}
			} catch (IOException e) {
				Log.e(TAG, e.getMessage());
			}

		}
		
		public void cancel() {
			try {
				mmSocket.close();
			} catch (IOException e) {
			}
		}
		
		
	}
	

	private class ConnectThread extends Thread {
		private final BluetoothSocket mmSocket;

		public ConnectThread(BluetoothSocket socket) {
			mmSocket = socket;
		}

		public void run() {

			try {
				mmSocket.getOutputStream().write("state".getBytes());
				finish();
			} catch (IOException connectException) {
				// Unable to connect; close the socket and get out
				Log.e(TAG, connectException.getMessage());
				try {
					mmSocket.close();
				} catch (IOException closeException) {
					Log.e(TAG, closeException.getMessage());
				}
			}

		}

		/** Will cancel an in-progress connection, and close the socket */
		public void cancel() {
			try {
				mmSocket.close();
			} catch (IOException e) {
			}
		}
	}

}
